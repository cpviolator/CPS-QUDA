/*
 * Please do not edit this file.
 * It was generated using PAB's VML system.
 */

#include <alg/qpropw_arg.h>
CPS_START_NAMESPACE

bool_t
vml_SourceType (VML *vmls, char *name,SourceType *objp)
{
	if (!vml_enum (vmls,name,(enum_t *)objp,SourceType_map))
		return FALSE;
	return TRUE;
}
struct vml_enum_map SourceType_map[] = {
	{"SourceType","POINT",POINT},
	{"SourceType","VOLUME",VOLUME},
	{"SourceType","WALL",WALL},
	{"SourceType","BOX",BOX},
	{"SourceType","RANDVOLUME",RANDVOLUME},
	{"SourceType","RANDWALL",RANDWALL},
	{"SourceType","RANDSLAB",RANDSLAB},
	{"SourceType","MESSEQ",MESSEQ},
	{"SourceType","PROT_U_SEQ",PROT_U_SEQ},
	{"SourceType","PROT_D_SEQ",PROT_D_SEQ},
	{"SourceType","UNDEF",UNDEF},
	{"SourceType","DERIV",DERIV},
	{"SourceType","GAUSS_GAUGE_INV",GAUSS_GAUGE_INV},
	{"SourceType","EXP",EXP},
	{"SourceType","SUM_MOM",SUM_MOM},
	{"SourceType","FL_FUNC",FL_FUNC},
	{"SourceType","MOM",MOM},
	{"SourceType","BOX_4D",BOX_4D},
	{NULL,NULL,0}
};

bool_t
vml_RandomType (VML *vmls, char *name,RandomType *objp)
{
	if (!vml_enum (vmls,name,(enum_t *)objp,RandomType_map))
		return FALSE;
	return TRUE;
}
struct vml_enum_map RandomType_map[] = {
	{"RandomType","GAUSS",GAUSS},
	{"RandomType","UONE",UONE},
	{"RandomType","ZTWO",ZTWO},
	{"RandomType","ZTWOXZTWO",ZTWOXZTWO},
	{"RandomType","NORAND",NORAND},
	{NULL,NULL,0}
};
	 bool QPropWArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool QPropWArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool QPropWArg::Vml(VML *vmls,char *instance){
		 if(!vml_QPropWArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_QPropWArg (VML *vmls, char *name,QPropWArg *objp)
{
	 vml_class_begin(vmls,"QPropWArg",name);
	 if (!vml_CgArg (vmls, "cg", &objp->cg))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 if (!vml_int (vmls, "x", &objp->x))
		 return FALSE;
	 if (!vml_int (vmls, "y", &objp->y))
		 return FALSE;
	 if (!vml_int (vmls, "z", &objp->z))
		 return FALSE;
	 if (!vml_int (vmls, "t", &objp->t))
		 return FALSE;
	 if (!vml_int (vmls, "gauge_fix_src", &objp->gauge_fix_src))
		 return FALSE;
	 if (!vml_int (vmls, "gauge_fix_snk", &objp->gauge_fix_snk))
		 return FALSE;
	 if (!vml_int (vmls, "smeared_src", &objp->smeared_src))
		 return FALSE;
	 if (!vml_int (vmls, "smeared_snk", &objp->smeared_snk))
		 return FALSE;
	 if (!vml_int (vmls, "store_midprop", &objp->store_midprop))
		 return FALSE;
	 if (!vml_int (vmls, "save_prop", &objp->save_prop))
		 return FALSE;
	 if (!vml_int (vmls, "save_ls_prop", &objp->save_ls_prop))
		 return FALSE;
	 if (!vml_int (vmls, "do_half_fermion", &objp->do_half_fermion))
		 return FALSE;
	 if (!vml_SourceType (vmls, "SeqSmearSink", &objp->SeqSmearSink))
		 return FALSE;
	 if (!vml_string (vmls, "ensemble_label", &objp->ensemble_label, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "ensemble_id", &objp->ensemble_id, ~0))
		 return FALSE;
	 if (!vml_int (vmls, "seqNum", &objp->seqNum))
		 return FALSE;
	 if (!vml_int (vmls, "StartSrcSpin", &objp->StartSrcSpin))
		 return FALSE;
	 if (!vml_int (vmls, "EndSrcSpin", &objp->EndSrcSpin))
		 return FALSE;
	 if (!vml_int (vmls, "StartSrcColor", &objp->StartSrcColor))
		 return FALSE;
	 if (!vml_int (vmls, "EndSrcColor", &objp->EndSrcColor))
		 return FALSE;
	 vml_class_end(vmls,"QPropWArg",name);
	return TRUE;
}
	 bool QPropWGFArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool QPropWGFArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool QPropWGFArg::Vml(VML *vmls,char *instance){
		 if(!vml_QPropWGFArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_QPropWGFArg (VML *vmls, char *name,QPropWGFArg *objp)
{
	 vml_class_begin(vmls,"QPropWGFArg",name);
	 if (!vml_int (vmls, "gauge_fix_src", &objp->gauge_fix_src))
		 return FALSE;
	 vml_class_end(vmls,"QPropWGFArg",name);
	return TRUE;
}
	 bool QPropWPointArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool QPropWPointArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool QPropWPointArg::Vml(VML *vmls,char *instance){
		 if(!vml_QPropWPointArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_QPropWPointArg (VML *vmls, char *name,QPropWPointArg *objp)
{
	 vml_class_begin(vmls,"QPropWPointArg",name);
	 if (!vml_int (vmls, "x", &objp->x))
		 return FALSE;
	 if (!vml_int (vmls, "y", &objp->y))
		 return FALSE;
	 if (!vml_int (vmls, "z", &objp->z))
		 return FALSE;
	 vml_class_end(vmls,"QPropWPointArg",name);
	return TRUE;
}
	 bool QPropWBoxArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool QPropWBoxArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool QPropWBoxArg::Vml(VML *vmls,char *instance){
		 if(!vml_QPropWBoxArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_QPropWBoxArg (VML *vmls, char *name,QPropWBoxArg *objp)
{
	 vml_class_begin(vmls,"QPropWBoxArg",name);
	 if (!vml_int (vmls, "box_start", &objp->box_start))
		 return FALSE;
	 if (!vml_int (vmls, "box_end", &objp->box_end))
		 return FALSE;
	 if (!vml_int (vmls, "use_xyz_offset", &objp->use_xyz_offset))
		 return FALSE;
	 vml_class_end(vmls,"QPropWBoxArg",name);
	return TRUE;
}
	 bool QPropW4DBoxArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool QPropW4DBoxArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool QPropW4DBoxArg::Vml(VML *vmls,char *instance){
		 if(!vml_QPropW4DBoxArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_QPropW4DBoxArg (VML *vmls, char *name,QPropW4DBoxArg *objp)
{
	 vml_class_begin(vmls,"QPropW4DBoxArg",name);
	int i;
	 if (!vml_vector (vmls, "box_start", (char *)objp->box_start, 4,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_vector (vmls, "box_size", (char *)objp->box_size, 4,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_vector (vmls, "mom", (char *)objp->mom, 4,
		sizeof (Float), (vmlproc_t) vml_Float))
		 return FALSE;
	 vml_class_end(vmls,"QPropW4DBoxArg",name);
	return TRUE;
}
	 bool QPropWRandArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool QPropWRandArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool QPropWRandArg::Vml(VML *vmls,char *instance){
		 if(!vml_QPropWRandArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_QPropWRandArg (VML *vmls, char *name,QPropWRandArg *objp)
{
	 vml_class_begin(vmls,"QPropWRandArg",name);
	 if (!vml_RandomType (vmls, "rng", &objp->rng))
		 return FALSE;
	 if (!vml_int (vmls, "seed", &objp->seed))
		 return FALSE;
	 vml_class_end(vmls,"QPropWRandArg",name);
	return TRUE;
}
	 bool QPropWSlabArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool QPropWSlabArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool QPropWSlabArg::Vml(VML *vmls,char *instance){
		 if(!vml_QPropWSlabArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_QPropWSlabArg (VML *vmls, char *name,QPropWSlabArg *objp)
{
	 vml_class_begin(vmls,"QPropWSlabArg",name);
	 if (!vml_QPropWRandArg (vmls, "rand_arg", &objp->rand_arg))
		 return FALSE;
	 if (!vml_int (vmls, "slab_width", &objp->slab_width))
		 return FALSE;
	 vml_class_end(vmls,"QPropWSlabArg",name);
	return TRUE;
}
	 bool QPropWExpArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool QPropWExpArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool QPropWExpArg::Vml(VML *vmls,char *instance){
		 if(!vml_QPropWExpArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_QPropWExpArg (VML *vmls, char *name,QPropWExpArg *objp)
{
	 vml_class_begin(vmls,"QPropWExpArg",name);
	 if (!vml_Float (vmls, "exp_A", &objp->exp_A))
		 return FALSE;
	 if (!vml_Float (vmls, "exp_B", &objp->exp_B))
		 return FALSE;
	 if (!vml_Float (vmls, "exp_C", &objp->exp_C))
		 return FALSE;
	 vml_class_end(vmls,"QPropWExpArg",name);
	return TRUE;
}
	 bool QPropWGaussArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool QPropWGaussArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool QPropWGaussArg::Vml(VML *vmls,char *instance){
		 if(!vml_QPropWGaussArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_QPropWGaussArg (VML *vmls, char *name,QPropWGaussArg *objp)
{
	 vml_class_begin(vmls,"QPropWGaussArg",name);
	int i;
	 if (!vml_int (vmls, "gauss_N", &objp->gauss_N))
		 return FALSE;
	 if (!vml_Float (vmls, "gauss_W", &objp->gauss_W))
		 return FALSE;
	 if (!vml_int (vmls, "nt", &objp->nt))
		 return FALSE;
	 if (!vml_vector (vmls, "mt", (char *)objp->mt, 5,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_GaussianKernelLinkSmearType (vmls, "gauss_link_smear_type", &objp->gauss_link_smear_type))
		 return FALSE;
	 if (!vml_int (vmls, "gauss_link_smear_N", &objp->gauss_link_smear_N))
		 return FALSE;
	 if (!vml_Float (vmls, "gauss_link_smear_coeff", &objp->gauss_link_smear_coeff))
		 return FALSE;
	 //Begin QUDA-CPS
	 if (!vml_int (vmls, "gauss_link_smear_ortho", &objp->gauss_link_smear_ortho))
		 return FALSE;
	 //Begin QUDA-CPS
	 vml_class_end(vmls,"QPropWGaussArg",name);
	return TRUE;
}
CPS_END_NAMESPACE
